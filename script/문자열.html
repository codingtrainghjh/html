<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>문자열</title>
  </head>
  <body>
    <script>
      const num1=123;
      const num2 = 123.45;
      const boo1=true;
      const str='문자열타입';
      const arr = [1,2,'a','b,',3];
      const obj = {key: 'data', value: 15};

      console.log(num1.toString()); //'123' 반환
      console.log(num2.toString()); //'123.45' 반환
      console.log(boo1.toString()); // 'true' 반환. 또는 'false'반환
      console.log(str.toString());  //'문자열타입' 반환.
      console.log(arr.toString());
      console.log(obj.toString());
      console.log(obj.key.toString());
      console.log(obj.value.toString());

      const str1 = 'good morning, good afternoon, good evening, and good night';
      console.log(str1.indexOf('even')); //35를 반환
      //문자열 뒤에서부터 'good'이 처음 나오는 시작 위치를 반환함.
      console.log(str1.lastIndexOf('good')); //48을 반환
      console.log(str1.lastIndexOf('dawn')); //-1을 반환함

      //첫번째 'good'과 두번째 'good'을 건너뛰고 3번째 'good'의 시작 인덱스를 반환합니다.
      console.log(str1.indexOf('good',15)); //30을 반환합니다.

      console.log(str1.charAt(30)); //'g'를 반환.
      console.log(str1.charAt(100)); //''를 반환.

      console.log(str1.includes('even')); //true를 반환
      console.log(str1.includes('dawn')); //false를 반환

      const str2 = 'good morning, good afternoon, GOOD EVENING, AND GOOD NIGHT';
      console.log(str2.toLowerCase().indexOf('good')); //0을 반환
      console.log(str2.toUpperCase().indexOf('GOOD')); //0을 반환
      console.log(str2.search('GOOD')); //31을 반환
      console.log(str2.search(/GOOD/i)); //0을 반환

      const str3 = 'bad MORNING, GOOD AFTERNOON, good evening, and good night';
      //'good' 뒤에 공백 1개가 있고 그 뒤에 단어 1개가 있는 패턴인 것을 모두 찾음
      console.log(str1.match(/good\s\w+/gi)); //["GOOD AFTERNOON", "good evening", "good night"]을 반환
      
      //'bad' 뒤에 공백 1개가 있고 그 뒤에 단어 1개가 있는 패턴인 것을 모두 찾음
      console.log(str1.match(/bad\s\w+/gi));

      //'none' 뒤에 공백 1개가 있고 그 뒤에 단어 1개가 있는 패턴인 것을 모두 찾음
      console.log(str1.match(/none\s\w+/gi)); //null 리턴

      //'good' 문자열인 것 1개를 찾음.
      console.log(str1.match('good')); //["good"]

      const str4 ="GOOD MORNING, GOOD AFTERNOON, good evening, and good night";
      console.log(str4.replace('good','bad'));

      //문자열을 모두 소문자로 변환한 후, 처음 나오는 찾는 문자열을 대상 문자열로 변경합니다.
      console.log(str4.toLowerCase().replace('good','bad'));

      //대소문자 구분 없이 처음 나오는 찾는 문자열을 대상 문자열로 변경합니다.
      console.log(str4.replace(/good/i,'bad'));

      //대소문자 구분 없이 나오는 모든 찾는 문자열을 대상 문자열로 변경합니다.
      console.log(str1.replace(/good/gi, 'bad'));

      let strarr = ['good', '', 'morning', '!'];
      console.log(''.concat(...strarr)); //'good morning!' 을 반환
      console.log('-----------------------------------------------------');

      let str5 = 'good';
      //중간 함수 taggedFunc 바로 뒤에 역따옴표로 감싼 템플릿 리터럴을 붙여서 파라메터로 넘깁니다.
      let result = taggedFunc`${str5} morning, ${str5} afternoon, ${str5} evening, and ${str5} night`;
      console.log(result);

      function taggedFunc(strings, exp){
        //반환값 저장 변수
        let ret = '';
        for(let idx=1; idx < strings.length; idx++){
          //루프를 도는 시작 인덱스와 개수에 주의해야 합니다.
          //strings 가 표현식을 기준으로 분리한 나머지 문자열들의 배열이라는 것을 이해하면 쉽습니다.
          if(idx<strings.length-1){
            ret+='bad' + strings[idx]; //마지막 표현식이 아닌 경우 'bad' 문자열로 대입
          }else{
            ret += 'moon' + strings[idx]; //마지막 표현식이 아닌 경우 'moon' 문자열로 대입
          }
        }
        return ret; //결과 문자열 반환
      }

      let friends = [{name: '라이언', age:5},{name:'어피치', age:3}, {name:'콘', age:4}, {name:'프로도', age:2}];

      let template = `<ul>
        <li>이름:${friends[0].name}, 나이 :${friends[0].age}</li>
        <li>이름:${friends[1].name}, 나이 :${friends[1].age}</li>
        <li>이름:${friends[2].name}, 나이 :${friends[2].age}</li>
        <li>이름:${friends[3].name}, 나이 :${friends[3].age}</li>
        </ul>`
        console.log(template);
    </script>
  </body>
</html>